# -*- coding: utf-8 -*-

"""
generate-tag-files.py

Given a merged fasta file of all of the V and J sequences for alpha/beta TCR genes from IMGT for a given species,
 generate a complete series of k-mer tags tiled across their entire lengths, and associated inferred translation details

This can be used in conjunction with autoDCR to annotate TCRs to the allele level, retaining the maximum info possible

"""

import argparse
import datetime
import os
import re
import collections as coll
import autoDCR as dcr
from time import strftime, localtime

__email__ = 'jheather@mgh.harvard.edu'
__version__ = '0.1.1'
__author__ = 'Jamie Heather'


def args():
    """
    :return: argparse details of command line arguments passed to the script
    """

    # Help flag
    parser = argparse.ArgumentParser(
        description='generate-tag-files v' + __version__ + ': automatically generate tag and translation files'
                                                           'for use with autoDCR.')
    # Add arguments
    parser.add_argument('-in', '--fasta', type=str, required=True, help='FASTA file containing all the IMGT V/J '
                        'alpha/beta TCR genes for the species in question. Name for species, e.g. \'human.fasta\'.')

    parser.add_argument('-sw', '--sliding_window', type=int, required=False, default=20,
                        help='Length of tag sliding window. Optional. Default = 20.')

    return parser.parse_args()


def get_gene(string):
    """
    :param string: a string containing an IMGT gene name - likely a FASTA header, or something derived from it
    :return: the IMGT gene/allele, and its corresponding functionality and partiality information
    """
    bits = string.split('|')
    return bits[1], bits[3], bits[13]


def fastafy(gene, seq_line):
    """
    :param gene: Gene symbol, extracted from the read id
    :param seq_line: Total protein primary sequence, extracted from input FASTA/generated by in silico splicing
    :return: An output-compatible FASTA entry ready for writing to file
    """
    return ">" + gene + "\n" + seq_line + "\n"


def translate(seq):
    """
    :param seq: Nucleotide sequence
    :return: Translated nucleotide sequence, with overhanging 3' (J) residues trimmed
    """
    protein = ""
    # Trim sequence length to a multiple of 3 (which in this situation should just be removing the terminal J residue)
    difference = len(seq) % 3
    if difference != 0:
        seq = seq[:-difference]
    for i in range(0, len(seq), 3):
        codon = seq[i:i + 3]
        protein += dcr.codons[codon]
    return protein


def get_jump(gene_name, tag_number):
    """
    Determine the jump value for proper translation of a rearrangement using a particular gene
    :param gene_name: IMGT gene name, as caught in the 'relevant_genes' variable
    :param tag_number: position of the index of that tag in its source gene
    :return:
    """
    if gene_name[3] == 'V':
        return tag_number
    elif gene_name[3] == 'J':
        return -abs(tag_number - len(full_genes[gene_name]))
    else:
        raise IOError("Unrecognised gene type detected: " + gene_name)


if __name__ == '__main__':

    r = '\n'                        # Carriage return, for log text
    lb = '-----\t-----' + r         # Line break, for log text

    log_str = 'Running generate-tag-files.py version:\t' + __version__ + '\nRun on:\t ' + \
              datetime.datetime.today().date().isoformat() + ' ' + datetime.datetime.today().time().isoformat() + r

    input_args = vars(args())
    input_file = input_args['fasta']
    if not os.path.exists(input_file):
        raise IOError("Cannot find source IMGT input TCR FASTA file.")
    else:
        nam = input_file.split('.')[0]
        last_mod = strftime('%Y-%m-%d %H:%M:%S', localtime(os.path.getmtime(input_file)))
        log_str += 'Input FASTA file:\t' + input_file + r + 'Input FASTA last modified:\t' + last_mod + r

    slide_len = input_args['sliding_window']
    log_str += 'Sliding window length used:\t' + str(slide_len) + r + lb
    if slide_len != 20:
        print("NB: non-default sliding window length used.")

    # Run here for non-specific (all in one file)
    tiles = coll.defaultdict(list)
    slides = coll.defaultdict(list)
    slides_count = coll.Counter()
    full_genes = coll.defaultdict()
    functionalities = coll.defaultdict()
    partials = coll.defaultdict()

    # First read in all the full length genes
    with open(input_file, 'r') as in_file:
        for readid, seq, qual in dcr.readfq(in_file):
            gene, func, partial = get_gene(readid)
            full_genes[gene] = seq.upper()

            window = full_genes[gene]
            functionalities[gene] = func
            partials[gene] = partial

            # Take sliding windows across the full length genes, overlapping by half their length
            for i in range(0, len(window) - slide_len + 1, int(slide_len/2)):

                slide = window[i:i+slide_len]
                if len(slide) == slide_len:
                    tiles[gene].append(slide)
                    slides[slide].append(gene)
                    slides_count[slide] += 1

    # Annotate all tags with all genes they appear in (regardless of window!)
    for tag in slides:
        for gene in full_genes:
            if tag in full_genes[gene]:
                if gene not in slides[tag]:
                    slides[tag].append(gene)

    # Determine the 'jump', and start to prepare the final out strings to be written
    # Jump = how many nucleotides are there between the start of the tag and the relevant recombined edge of the gene
    # I.e. V jumps = position in gene running 5'-3', J jumps = negative values relative to 3' edge
    # NB not truly needed, no longer used by autoDCR, but useful when manually verifying tag sequences
    jumps = {}
    all_tags = list(slides.keys())
    all_tags.sort()
    out_str = []
    manually_verify = False
    for tag in all_tags:

        # If only one gene/allele covered by a tag, take its jump
        # If multiple, output a list of each corresponding jump
        # Note that many will be the same if for multiple alleles of same gene
        relevant_genes = slides[tag]

        if len(relevant_genes) == 0:
            raise IOError("Somehow a tag has been generated that covers no genes: " + tag)

        elif len(relevant_genes) == 1:
            tag_index = full_genes[relevant_genes[0]].index(tag)
            jumps = str(get_jump(relevant_genes[0], tag_index))
            tag_names = relevant_genes[0]

        else:
            relevant_genes.sort()
            tag_indices = [full_genes[x].index(tag) for x in relevant_genes]
            jumps = ','.join([str(get_jump(relevant_genes[x], tag_indices[x])) for x in range(len(tag_indices))])
            tag_names = ','.join(relevant_genes)

        # Add to output, ensuring each tag has the information of all genes covered and their respective jumps
        out_str.append('\t'.join([tag, jumps, tag_names]))

    # Sanity check that this contains both (and only) properly named V & J genes
    all_genes = list(full_genes.keys())
    all_genes.sort()

    log_str += 'Number genes covered:\t' + str(len(all_genes)) + r + 'Number tags made:\t' + str(len(out_str)) + r

    if set([x[3] for x in all_genes]) != {'V', 'J'}:
        raise IOError('Please ensure input fasta file contains both V and J genes, properly named as per IMGT.')

    # Then write out tags, and begin to look for translation parameters
    with open(nam + '.tags', 'w') as out_file:
        out_file.write('\n'.join(out_str))

    all_vs = [x for x in all_genes if 'V' in x]
    all_vs.sort()

    log_str += lb + 'Number V genes covered:\t' + str(len(all_vs)) + r + 'Flagged V genes below:\t' + r

    positions = coll.defaultdict(list)
    motifs = coll.defaultdict(list)

    # If there's only one C residue in the C terminus of the V, take that as the C terminal residue.
    # NB the residue immediately prior to the conserved C is usually an L or an F...
    # ... and the residue before that is almost always a Y

    context_len = 5
    sanity_len = 10
    for v in all_vs:
        found = 0
        translation = translate(full_genes[v])
        last_c = translation.rfind('C')

        # Sanity check - is the most C-terminal C residue within a reasonable distance of the end of the V?
        if len(translation) - last_c > sanity_len:

            log_str += v + ":\t Had no conserved C within " + str(sanity_len) + " translated residues from the " \
                           "edge of the gene. "

            if functionalities[v] in ['F', '(F)', '[F]']:
                log_str += "Gene is recorded as functional. "

                if "3'" in partials[v]:
                    log_str += "Gene sequence is also partial in 3', so conserved C was presumably lost. "

                    proto = v[:-3] + '*01'
                    if (v != proto) and (proto in positions):
                        positions[v] = positions[proto]
                        motifs[v] = motifs[proto]
                        log_str += "Using the translation details from the prototypical allele " + proto + '.' + r
                        continue

                    else:
                        log_str += "No suitable prototypical allele (*01) to copy from. Manually verify. " + r
                        manually_verify = True

                else:
                    log_str += "However the gene sequence is reportedly complete. Manually verify. " + r
                    manually_verify = True

            else:
                log_str += "Gene is not recorded as functional: this may be why. "
                if functionalities[v] == 'ORF':
                    log_str += "Gene is recorded as an ORF: consider verification. " + r
                else:
                    log_str += "Gene is recorded as a pseudogene, and thus unlikely to translate anyway. " \
                               "Taking most 3'." + r

        else:
            # The other possibility is that there are multiple Cs in the immediate 3' of the V gene
            context = translation[last_c - context_len:last_c + 1]

            if coll.Counter([x for x in context])['C'] > 1:

                log_str += v + ":\t Has multiple potential conserved C residues in its 3'. "

                # Disregard if pseudogene (most of the multiple Cys V genes)
                if functionalities[v] in ['P', '(P)', '[P]']:
                    log_str += "Gene is recorded as a pseudogene, and thus unlikely to translate anyway. " \
                               "Taking most 3'." + r

                # Otherwise try to use the knowledge that certain residues often precede the conserved C
                else:
                    cs = [x for x, residue in enumerate(translation) if 'C' in residue]

                    # Only look in first two, as I'm yet to find a functional V with > 2 Cs in its 3'
                    for c in cs[-2:]:
                        # Then take the 5' most of those two that matches
                        if translation[c-1] in ['L', 'Y', 'F']:
                            positions[v] = c
                            motifs[v] = 'C'

                            log_str += "Taking position " + str(c) + " as it's preceded by a " + translation[c-1] + \
                                " residue, which often precedes the conserved Cys." + r
                            picked = True
                            continue

                    if picked:
                        continue
                    else:
                        log_str += "Unable to choose between the C residues based on the presence of a known motif. " \
                                   "Manually verify." + r
                        manually_verify = True

        positions[v] = last_c
        motifs[v] = translation[last_c]
        # TODO also need to account for psuedogenes etc that don't have required motifs
        # (e.g. TRBV7-3*02/03, which has R instead of conserved C)

    # Then try to find conserved J gene motifs
    all_js = [x for x in all_genes if 'J' in x]
    all_js.sort()
    poss_motifs = ['FG.G', 'WG.G', 'CG.G', 'F..G', 'FG..', 'LG.G']

    log_str += lb + 'Number J genes covered:\t' + str(len(all_js)) + r + 'Flagged J genes below:\t' + r
    for j in all_js:
        # Go through all J genes, finding the right frame and the conserved F
        # NB Start at -11/-10 positions for TRAJ/TRBJ amino acid sequences - defines the 'base' expected motif site
        if 'TRAJ' in j:
            nt_start = -34
        elif 'TRBJ' in j:
            nt_start = -31

        # Check to see whether the IMGT J gene is cDNA only (as those omit the last nucleotide)
        if functionalities[j] == '(F)':
            nt_start += 1
            modifier = 1
        else:
            modifier = 0

        base = translate(full_genes[j][nt_start:nt_start + 12])
        # Get AA seq. NB: end of the J needs to be in frame, not the start (after deleting the base that splices to C)
        modulo = (len(full_genes[j]) - 1 + modifier) % 3
        translation = translate(full_genes[j][modulo:])
        # If you can't find a motif at the canonical site, look elsewhere
        if not [y[0] for y in [re.findall(x, base) for x in poss_motifs] if y]:
            search = list(set([y[0] for y in [re.findall(x, translation) for x in poss_motifs] if y]))
            if len(search) == 1:
                seq_search = (translation.index(search[0]) * 3) + modulo
                nt_start = seq_search - len(full_genes[j])
                log_str += j + ":\tNon-standard position for conserved CDR3 junction ending motif."
                if translate(full_genes[j][nt_start:nt_start + 12]) != search[0]:
                    log_str += j + ":\tNon-standard position for conserved CDR3 junction ending motif. " \
                                   "Manually verify. "
                    manually_verify = True

        positions[j] = int((nt_start + 1 - modifier) / 3)
        motifs[j] = translation[positions[j]]

    all_genes = all_vs + all_js
    out_str = []

    for gene in all_genes:
        out_str.append('\t'.join([gene, str(positions[gene]), motifs[gene]]))

    with open(nam + '.translate', 'w') as out_file:
        out_file.write('\n'.join(out_str))

    # Finally output the log file, containing the details of this specific run
    with open(nam + '.log', 'w') as out_file:
        out_file.write(log_str)

    if manually_verify:
        raise ValueError("Warning: V and/or J genes with irregular CDR3 junction ending motifs discovered, from which "
                         "the conserved positions required for translations could not be automatically assigned.\n"
                         "Please refer to log file, manually verify, and update the " + nam + ".translate file.")

# TODO allow users to provide an additional file to specifically override/supply irregular translation details?
