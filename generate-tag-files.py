# -*- coding: utf-8 -*-

"""
generate-tag-files.py

Given a merged fasta file of all of the V and J sequences for alpha/beta TCR genes from IMGT for a given species,
 generate a complete series of k-mer tags tiled across their entire lengths, and associated inferred translation details

This can be used in conjunction with autoDCR to annotate TCRs to the allele level, retaining the maximum info possible

"""

import argparse
import datetime
import os
import re
import shutil
import collections as coll
import autoDCR as dcr
from time import strftime, localtime

__email__ = 'jheather@mgh.harvard.edu'
__version__ = '0.2.1'
__author__ = 'Jamie Heather'


def args():
    """
    :return: argparse details of command line arguments passed to the script
    """

    # Help flag
    parser = argparse.ArgumentParser(
        description="generate-tag-files v" + __version__ + ": automatically generate tag and translation files"
                    "for use with autoDCR.")
    # Add arguments
    parser.add_argument('-in', '--fasta', type=str, required=True, help="FASTA file containing all the IMGT V/J alpha/"
                        "beta TCR genes for the species in question. It\'s recommended to include date+release info.")

    parser.add_argument('-sw', '--sliding_window', type=int, required=False, default=20,
                        help="Length of tag sliding window. Optional. Default = 20.")

    parser.add_argument('-sp', '--species', type=str, required=False, default='human', help="String of species name, "
                        "used to prefix all output fields. Default = 'human'.")

    return parser.parse_args()


def get_gene(string):
    """
    :param string: a string containing an IMGT gene name - likely a FASTA header, or something derived from it
    :return: the IMGT gene/allele, and its corresponding functionality and partiality information
    """
    bits = string.split('|')
    return bits[1], bits[3], bits[13]


def fastafy(gene, seq_line):
    """
    :param gene: Gene symbol, extracted from the read id
    :param seq_line: Total protein primary sequence, extracted from input FASTA/generated by in silico splicing
    :return: An output-compatible FASTA entry ready for writing to file
    """
    return ">" + gene + "\n" + seq_line + "\n"


def translate(seq):
    """
    :param seq: Nucleotide sequence
    :return: Translated nucleotide sequence, with overhanging 3' (J) residues trimmed
    """
    protein = ""
    # Trim sequence length to a multiple of 3 (which in this situation should just be removing the terminal J residue)
    difference = len(seq) % 3
    if difference != 0:
        seq = seq[:-difference]
    for i in range(0, len(seq), 3):
        codon = seq[i:i + 3]
        protein += dcr.codons[codon]
    return protein


def find_cys(regex, search_str):
    """
    :param regex: str describing a regular expression to search for
    :param search_str: str of a sequence to search within
    :return: the index of the putative conserved Cys reg based on the last instance of that given regex
    """
    hits = [search_str.rfind(x) + len(x) - 1 for x in re.findall(regex, search_str)]
    if hits:
        return hits[-1]
    else:
        return


def get_jump(gene_name, tag_number):
    """
    Determine the jump value for proper translation of a rearrangement using a particular gene
    :param gene_name: IMGT gene name, as caught in the 'relevant_genes' variable
    :param tag_number: position of the index of that tag in its source gene
    :return:
    """
    if gene_name[3] == 'V':
        return tag_number
    elif gene_name[3] == 'J':
        return -abs(tag_number - len(full_genes[gene_name]))
    else:
        raise IOError("Unrecognised gene type detected: " + gene_name)


def log_functionality(funct_dict, allele_name):
    """
    :param funct_dict: dict of strs of functionalities of each gene
    :param allele_name: str of the full gene*allele name in question
    :return: string describing the functionality of the allele in question
    """
    if allele_name not in funct_dict:
        return "Error: gene not found in 'funct_dict' dictionary! "

    elif funct_dict[allele_name] in ['F', '(F)', '[F]']:
        return "Gene is recorded as functional, and expected to be able to make working TCRs. "

    elif funct_dict[allele_name] == 'ORF':
        return "Gene is recorded as an ORF, and thus might not be able to make working TCRs. "

    elif funct_dict[allele_name] in ['P', '(P)', '[P]']:
        return "Gene is recorded as a pseudogene, and thus expected to not make working TCRs. "

    else:
        return "Error: gene has an indeterminate functionality (" + funct_dict[allele_name] + "). "


def log_partiality(part_dict, allele_name, allele_type):
    """
    :param part_dict: dict of str of partial sequence information (where available)
    :param allele_name: str of name of allele (gene*allele)
    :param allele_type: str of 'V' or 'J'
    :return: str (if gene == V which is partial in 3') or nothing
    """
    if allele_type == 'V':
        if "3'" in part_dict[allele_name]:
            return "Gene sequence is also partial in 3', so conserved C was potentially lost. "
        else:
            return ''
    else:
        return ''


def find_motif(regex_list, allele_name, type_gene, allele_seq, func_str):
    """
    :param regex_list: list of strings describing regular expressions to search for
    :param allele_name: str of name (gene*allele) of allele in question
    :param type_gene: str specifying the gene type ('V' or 'J')
    :return: aa_seq, index of the (first detected) putative conserved motif, motif used, and the residue
    NB: requires 'regexes' and 'j_pos' to be globally declared
    """

    # Vs can just be directly translated, as V-REGIONS start in-frame
    if type_gene == 'V':
        aa_seq = translate(allele_seq)
        for regex in regex_list:
            # Return the 3' most hit
            hits = [aa_seq.rfind(x) + len(x) - 1 for x in re.findall(regex, aa_seq)]
            if hits:
                return aa_seq, hits[-1], regex, aa_seq[hits[-1]]

        return [''] * 4

    # Js are trickier, requiring determination of the right frame, and conserved motifs lying in different registers
    # Start at -11/-10 positions for TRAJ/TRBJ amino acid sequences - defines the 'base' expected motif site
    elif type_gene == 'J':
        if func_str == '(F)':
            # nt_start += 1
            modifier = 1
        else:
            modifier = 0

        # Get AA seq. NB: end of the J needs to be in frame, not the start (after deleting the base that splices to C)
        modulo = (len(allele_seq) - 1 + modifier) % 3
        aa_seq = translate(allele_seq[modulo:])

        backups = [aa_seq, '', '', '']
        backup_dist = 0

        for regex in regex_list:
            # Now we want the 5' index of the hits (the F position)
            hits = [-(len(aa_seq) - aa_seq.index(x)) for x in re.findall(regex, aa_seq)]

            if len(hits) == 1:
                return aa_seq, hits[0], regex, aa_seq[hits[0]]

            elif len(hits) > 1:
                expected_hit = [x for x in hits if x == j_pos[allele_name[:4]]]
                if expected_hit:
                    return aa_seq, expected_hit[0], regex, aa_seq[expected_hit[0]]

                # Keep tabs of the 'least worst' alternative if no single good hit in the right place found
                for hit in hits:
                    if abs(j_pos[allele_name[:4]] - hit) > backup_dist:
                        backup_dist = abs(j_pos[allele_name[:4]] - hit)
                        backups[1:] = [hit, regex, aa_seq[hit]]

        # If we made it here we didn't get a good hit
        if backup_dist != 0:
            return backups
        else:
            return [''] * 4

    else:
        raise IOError("Unexpected gene type detected (" + type_gene + ")! ")


def find_junction_residues(all_gene_list, full_gene_dict, func_dict, partial_dict, log_text):
    """
    :param all_gene_list: list of all gene*alleles input
    :param full_gene_dict: dict of full nt seqs of gens
    :param func_dict: dict of strs of recorded (predicted) functionality of each allele
    :param partial_dict: dict of strings of partiality (i.e. whether gene partial in 5'/3'/both, if applicable)
    :param log_text: str of text for log file, to be appended to
    :return: two strings to write out: that for the translate file, and the updated log file contents
    """

    positions = coll.defaultdict(list)
    motifs = coll.defaultdict(list)

    # If there's only one C residue in the C terminus of the V, take that as the C terminal residue.
    # NB the residue immediately prior to the conserved C is usually an L or an F...
    # ... and the residue before that is almost always a Y
    all_gene_list.sort()

    for ga in all_gene_list:
        log_text += '\n' + ga + '\t'

        gene_type = ga[3]
        if gene_type not in ['V', 'J']:
            raise IOError("Unexpected gene type (not V/J) detected: " + gene_type)

        func = log_functionality(func_dict, ga)
        part = log_partiality(partial_dict, ga, gene_type)

        # First try high-confidence motifs
        aa, position, motif, residue = find_motif(regexes[gene_type][1], full_gene_dict[ga],
                                                  gene_type, full_genes[ga], func_dict[ga])

        if motif:
            log_text += 'Found a high-confidence motif: "' + motif + '". '
            positions[ga] = position
            motifs[ga] = residue
            confidence = 'high'

        # If that fails, try less confident
        else:
            aa, position, motif, residue = find_motif(regexes[gene_type][2], full_gene_dict[ga],
                                                      gene_type, full_genes[ga], func_dict[ga])
            if motif:
                log_text += 'Found a lower-confidence motif: "' + motif + '". '
                positions[ga] = position
                motifs[ga] = residue
                confidence = 'low'
            else:
                log_text += 'Did not find a conserved residue motif - unable to translate. '
                positions[ga] = ''
                motifs[ga] = ''
                confidence = 'null'

        if positions[ga]:
            # If the detected C is far from the end, or gene is partial in 3', try to use the prototypical gene's call
            if gene_type == 'V':
                sanity_len_check = len(aa) - position > c_sanity_len

                if ((sanity_len_check or part) and confidence == 'low') or confidence == 'null':
                    proto = ga.split('*')[0] + '*01'
                    if (ga != proto) and (proto in positions):
                        positions[ga] = positions[proto]
                        motifs[ga] = motifs[proto]
                        log_text += ("Unable to find a high-confidence motif (close to the V region end) and/or gene"
                                     " is partial in it's 3 - using ") + proto + "'s. "

            # Also record whether the J motif is at the expected position relative to the 3' end of the gene
            elif gene_type == 'J':
                if position != j_pos[ga[:4]]:
                    log_text += 'J gene motif not at the expected location (' + str(j_pos[ga[:4]]) + '). '

        log_text += func + part

    all_vs = [x for x in all_gene_list if 'V' in x.split('*')[0]]
    all_vs.sort()

    all_js = [x for x in all_gene_list if 'J' in x.split('*')[0]]
    all_js.sort()

    all_vj = all_vs + all_js
    if len(all_vj) != len(all_gene_list):
        raise IOError('V+J gene count != all gene count! ')

    tag_text = []
    for gene in all_vj:
        tag_text.append('\t'.join([gene, str(positions[gene]), motifs[gene]]))

    return '\n'.join(tag_text), log_text


# Regular expressions used to determine location of conserved CDR3-definining residues
# Manually constructed from human TCR genes (TRA/TRB/TRG/TRD)
regexes = {'V': {1: ['[AST][AGS].Y[FILY].', '[AGS].Y[FILY].', '[AST]..Y[FILY].',
                     '[AST][AGS]..[FILY].', '[AST][AGS].Y..', '[AST][AGS].Y[FILY].'],
                 2: ['Y[FILY]C', 'Y.C', 'C']},
           'J': {1: ['FG.GT.[LV]', '.G.GT.[LV]', 'F..GT.[LV]', 'FG..T.[LV]', 'FG.G..[LV]', 'FG.GT.'],
                 2: ['FG.G', 'WG.G', 'CG.G', 'F..G', 'FG..', 'LG.G']}}

# Relative expected positions of conserved J gene FGXG motifs
j_pos = {'TRAJ': -11, 'TRBJ': -10}  # TODO include TRDJ/TRGJ?

c_sanity_len = 15


if __name__ == '__main__':

    r = '\n'                        # Carriage return, for log text
    lb = '-----\t-----' + r         # Line break, for log text

    log_str = 'Running generate-tag-files.py version:\t' + __version__ + '\nRun on:\t ' + \
              datetime.datetime.today().date().isoformat() + ' ' + datetime.datetime.today().time().isoformat() + r

    input_args = vars(args())
    input_file = input_args['fasta']
    if not os.path.exists(input_file):
        raise IOError("Cannot find source IMGT input TCR FASTA file.")
    else:
        nam = input_args['species']
        last_mod = strftime('%Y-%m-%d %H:%M:%S', localtime(os.path.getmtime(input_file)))
        log_str += 'Input FASTA file:\t' + input_file + r + 'Input FASTA last modified:\t' + last_mod + r

    # If input FASTA isn't named as the output, generate a copy
    if input_file.split('.')[0] != input_args['species']:
        shutil.copyfile(input_file, input_args['species'] + '.fasta')

    slide_len = input_args['sliding_window']
    log_str += 'Sliding window length used:\t' + str(slide_len) + r + lb
    if slide_len != 20:
        print("NB: non-default sliding window length used.")

    # Run here for non-specific (all in one file)
    tiles = coll.defaultdict(list)
    slides = coll.defaultdict(list)
    slides_count = coll.Counter()
    full_genes = coll.defaultdict()
    functionalities = coll.defaultdict()
    partials = coll.defaultdict()

    # First read in all the full length genes
    with open(input_file, 'r') as in_file:
        for readid, seq, qual in dcr.readfq(in_file):
            gene, func, partial = get_gene(readid)
            full_genes[gene] = seq.upper()

            window = full_genes[gene]
            functionalities[gene] = func
            partials[gene] = partial

            # Take sliding windows across the full length genes, overlapping by half their length
            for i in range(0, len(window) - slide_len + 1, int(slide_len/2)):

                slide = window[i:i+slide_len]
                if len(slide) == slide_len:
                    tiles[gene].append(slide)
                    slides[slide].append(gene)
                    slides_count[slide] += 1

    # Annotate all tags with all genes they appear in (regardless of window!)
    for tag in slides:
        for gene in full_genes:
            if tag in full_genes[gene]:
                if gene not in slides[tag]:
                    slides[tag].append(gene)

    # Determine the 'jump', and start to prepare the final out strings to be written
    # Jump = how many nucleotides are there between the start of the tag and the relevant recombined edge of the gene
    # I.e. V jumps = position in gene running 5'-3', J jumps = negative values relative to 3' edge
    # NB not truly needed, no longer used by autoDCR, but useful when manually verifying tag sequences
    jumps = {}
    all_tags = list(slides.keys())
    all_tags.sort()
    out_str = []
    manually_verify = False
    for tag in all_tags:

        # If only one gene/allele covered by a tag, take its jump
        # If multiple, output a list of each corresponding jump
        # Note that many will be the same if for multiple alleles of same gene
        relevant_genes = slides[tag]

        if len(relevant_genes) == 0:
            raise IOError("Somehow a tag has been generated that covers no genes: " + tag)

        elif len(relevant_genes) == 1:
            tag_index = full_genes[relevant_genes[0]].index(tag)
            jumps = str(get_jump(relevant_genes[0], tag_index))
            tag_names = relevant_genes[0]

        else:
            relevant_genes.sort()
            tag_indices = [full_genes[x].index(tag) for x in relevant_genes]
            jumps = ','.join([str(get_jump(relevant_genes[x], tag_indices[x])) for x in range(len(tag_indices))])
            tag_names = ','.join(relevant_genes)

        # Add to output, ensuring each tag has the information of all genes covered and their respective jumps
        out_str.append('\t'.join([tag, jumps, tag_names]))

    # Sanity check that this contains both (and only) properly named V & J genes
    all_genes = list(full_genes.keys())
    all_genes.sort()

    log_str += ('Number genes covered:\t' + str(len(all_genes)) + r +
                'Number tags made:\t' + str(len(out_str)) + r + lb)

    if set([x[3] for x in all_genes]) != {'V', 'J'}:
        raise IOError('Please ensure input fasta file contains both V and J genes, properly named as per IMGT.')

    # Then write out tags, and begin to look for translation parameters
    with open(nam + '.tags', 'w') as out_file:
        out_file.write('\n'.join(out_str))

    tag_str, log_str = find_junction_residues(all_genes, full_genes, functionalities, partials, log_str)

    # Finally output the tag and log files, containing the details of this specific run
    with open(nam + '.translate', 'w') as out_file:
        out_file.write(tag_str)

    with open(nam + '.log', 'w') as out_file:
        out_file.write(log_str)

# TODO allow users to provide an additional file to specifically override/supply irregular translation details?
