# -*- coding: utf-8 -*-

"""
inferTCR

This script reads in the output of autoDCR run with the 'allele discovery' (-ad) mode enabled,
and makes use of the non-contiguous tag events found therein to infer the presence of potential novel alleles.

"""


import argparse
import textwrap
import collections as coll
import autoDCR as dcr
import numpy as np
import pandas as pd
from copy import deepcopy
from ast import literal_eval

__email__ = 'jheather@mgh.harvard.edu'
__version__ = '0.1.2'
__author__ = 'Jamie Heather'


def args():
    """
    :return: argparse details of command line arguments passed to the script
    """

    # Help flag
    parser = argparse.ArgumentParser(
        description='infer-alleles v' + __version__ + ': infer potential novel TCR alleles from the output of autoDCR.')

    # Add arguments
    parser.add_argument('-in', '--in_repertoire', type=str, required=True,
                        help="Path to TCR repertoire file produced by autoDCR. 'X.tsv' or 'X.tsv.gz'.")

    parser.add_argument('-sp', '--species', type=str, required=False, default="human",
                        help='Specify which species TCR repertoire the data consists of. Default = human')

    parser.add_argument('-dd', '--data_dir', type=str, required=False,
                        help="Optionally specify a path to a directory containing the required germline TCR data \n"
                             "(i.e. the 'X.fasta', 'X.tags', and 'X.translate' files)")

    return parser.parse_args()


def initialise(input_arguments):
    """
    :param input_arguments: Command line arguments
    :return: Decombinator formatted arguments
    """
    input_arguments['allele_discovery'] = False
    return dcr.import_tcr_info(input_arguments)


def format_mismatch_str(mm_str):
    """
    :param mm_str: Str containing mismatch information from autoDCR with the -ad flag used, relating to a dict
    :return: Mismatch information converted from a string to a dictionary
    """
    if isinstance(mm_str, str):
        return literal_eval(mm_str)
    elif np.isnan(mm_str):
        return ''
    else:
        raise IOError("Unknown input format")


def format_mismatches(mm_dict):
    """
    :param mm_dict: Dictionary of TCR mismatch information (i.e. as read in by format_mismatch_str)
    :return: Str with the ordered elements separated by pipe characters
    """
    if mm_dict:
        return '|'.join([str(mm_dict[x]) for x in mismatch_keys])


def imgt_fastafy(gene, seq_line, rename):
    """
    :param gene: Gene symbol, extracted from the read id
    :param seq_line: Total protein primary sequence, extracted from input FASTA/generated by in silico splicing
    :param rename: Boolean - whether to rename to IMGT format, or leave gene symbol as is
    :return: An output-compatible FASTA entry ready for writing to file
    """
    seq_len = str(len(seq_line))
    if rename:
        header = ">inferred|" + gene + "|Homo sapiens|(F)|" + gene[3] + "-REGION| |" + seq_len + \
                 " nt| | | | | |" + seq_len + "+0=" + seq_len + "| | |\n"
    else:
        if not gene.startswith('>'):
            gene = '>' + gene
        if not gene.endswith('\n'):
            gene += '\n'
        header = gene
    return header + textwrap.fill(seq_line, 60) + "\n"


def percentage(a, b):
    """
    :param a: Int or float value A
    :param b: Int or float value B
    :return: Float percentage value of a/b
    """
    return (a/b) * 100


def list_to_df(input_list, headers, rename):
    """
    Convert a list to a (long) dataframe. Note that first entry becomes the index if chosen
    :param input_list: List of list entries (with each position in each list corresponding to a column)
    :param headers: List of column headers. First column should be unique, becoming the rownames, if rename = True
    :param rename: Option to rename row IDs by first colum
    :return: sorted pandas dataframe
    """
    df = pd.DataFrame(input_list)
    df = df.rename(index=str, columns=dict(zip(range(len(headers)), headers)))
    df = df.sort_values(by=[headers[0]])
    if rename is True:
        df = df.set_index(headers[0], drop=True)
    return df


mismatch_keys = ['tag1_seq', 'tag2_seq', 'tag1_gl_index', 'tag2_gl_index', 'intervening']

if __name__ == '__main__':

    # Determine the requested input/output parameters
    input_args = vars(args())
    input_args = initialise(input_args)

    dat = pd.read_csv(input_args['in_repertoire'], sep='\t', compression='infer')

    dat['v_mismatches'] = [format_mismatch_str(x) for x in dat['v_mismatches']]
    dat['v_mismatch_str'] = [format_mismatches(x) for x in dat['v_mismatches']]

    # Prepare the column which will store the eventual gene call (deleting ambiguous gene calls)
    dat['v_call_final'] = dat['v_call']
    dat.loc[dat['v_call_final'].str.contains(','), 'v_call_final'] = ''

    # Pull out the full-length rearranged receptors
    flr = dat.loc[(dat['productive'] == 'T') & (dat['v_jump'] == 0)]

    # Go through unique V genes and begin to genotype
    vs = list(set([x.split('*')[0] for x in dcr.genes.keys() if 'V' in x]))
    vs.sort()

    inferred_alleles = coll.defaultdict()
    inferred_genotypes = []
    inferred_dfs = []
    inferred_summary = []

    for v in vs:
        subset = flr.loc[flr['v_call'].str.contains(v + '\*')]
        alleles = coll.Counter(subset['v_call'])

        # Only continue if there's sufficient rearrangements using this V
        if len(subset) < 10:
            continue

        # Pull out those flagged with non-contiguous tag matches
        non_cont = subset.loc[subset['v_mismatches'] != ""]

        # Then look to see whether there's one or two sequences which explain this diversity
        # Filter on sequences with shorter non-contiguous sections (longer = likely a splice event or miscall etc)
        non_cont['v_mismatch_len'] = [x['tag2_index'] - x['tag1_index'] for x in non_cont['v_mismatches']]
        non_cont_f = non_cont.loc[non_cont['v_mismatch_len'] <= 40]

        # Filter out if not accounting for a big enough fraction of the V
        if len(non_cont_f) / len(subset) > 0.05:
            pot_nov = coll.Counter(non_cont_f['v_mismatch_str'])

            # Only need to look in biggest two potential novel alleles (as there could only be a maximum of two)
            for pn in pot_nov.most_common(2):

                if pn[1] / len(non_cont_f) < 0.1 or pn[1] < 3:
                    continue

                # This potential novel allele occupies enough of the total usage of this V to merit attention
                # Need to determine the exact changes and give it a name
                candidates = non_cont_f.loc[non_cont_f['v_mismatch_str'] == pn[0]]
                base_gene = coll.Counter(candidates['v_call']).most_common(1)[0][0]

                # Filter out ambiguous gene calls
                if ',' in base_gene:
                    continue

                tag1, tag2, tag1_start, tag2_start, intervening = pn[0].split('|')
                unmatched_start = int(tag1_start) + len(tag1)
                intervening_gl = dcr.genes[base_gene][unmatched_start:int(tag2_start)]
                positions = [x for x in range(len(intervening)) if intervening[x] != intervening_gl[x]]

                # Name the actual polymorphisms, relative to the selected base gene,
                # ... and generate the novel allele by substitution
                changes = []
                seq_in_progress = list(dcr.genes[base_gene])
                for pos in positions:
                    edit_pos = unmatched_start + pos + 1  # Need to add one to offset from Python indexing
                    changes.append(intervening_gl[pos] + str(edit_pos) + intervening[pos])
                    if seq_in_progress[edit_pos - 1] == intervening_gl[pos]:
                        seq_in_progress[edit_pos - 1] = intervening[pos]
                pot_allele = '_'.join([base_gene] + changes)
                seq_in_progress = ''.join(seq_in_progress)
                inferred_alleles[pot_allele] = seq_in_progress

                pot_nov_df = subset.loc[subset['v_mismatch_str'] == pn[0]]
                subset.loc[subset['v_mismatch_str'] == pn[0], 'v_call_final'] = pot_allele
                inferred_dfs.append(deepcopy(pot_nov_df))

                inferred_summary.append(
                    [v, pot_allele, seq_in_progress,
                     len(subset), percentage(len(subset), len(dat)),
                     len(pot_nov_df), percentage(len(pot_nov_df), len(subset)),
                     len(list(set(pot_nov_df['junction']))),
                     len(list(set([x for x in pot_nov_df['j_call'] if ',' not in x])))])

        final_alleles = coll.Counter(subset['v_call_final'])
        if '' in final_alleles:
            final_alleles.pop('')
        inferred_genotypes.append(final_alleles)

    # Then write out all the relevant details
    if inferred_dfs:
        out_nam_base = input_args['in_repertoire'].split('/')[-1].split('.')[0]
        supporting_df = pd.concat(inferred_dfs, axis=0)
        supporting_df.to_csv(out_nam_base + '_sourcedata.tsv', sep='\t', index=False)

        summary = list_to_df(inferred_summary, ['gene', 'inferred_allele', 'sequence',
                                                '#_using_gene', '%_repertoire_using_gene',
                                                '#_using_inferred', '%_gene_using_inferred',
                                                '#_unique_cdr3s', '#_different_js'], False)
        summary.to_csv(out_nam_base + '_summary.tsv', sep='\t', index=False)

        with open(out_nam_base + '_alleles.fasta', 'w') as out_file:
            for ia in inferred_alleles:
                out_file.write(imgt_fastafy(ia, inferred_alleles[ia], True))

    else:
        print("No potential novel alleles detected.")

# TODO (potentially):
# Record all genotypes/associated values
# Record all inferred alleles/number of supporting evidence (# TCRs)
# Try to determine 3' end of inferred Vs?
# Auto-tabulate all supporting evidence for a particular inference
